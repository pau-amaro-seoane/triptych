import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

"""
Program: plot_density.py
Author: Pau Amaro Seoane
Date: 17 August 2024

Description:
------------
This Python script generates a heatmap that visualizes the maximum core density of stellar models 
as a function of various simulation parameters, such as relative velocity and periastron separation. 
The script reads the simulation results from a file named 'results.txt', which is generated by running 
the accompanying simulation script (e.g., run_simulations.sh). 

The heatmap is rendered using LaTeX for text formatting, ensuring high-quality labels and 
annotations. The script can be customized to adjust font sizes and other visual aspects 
of the plot.

The heatmap displays core density on the color bar with axes labeled by velocity and periastron separation.

Requirements:
-------------
1. Python 3.x
2. Required Python libraries:
   - pandas: For handling and processing the data.
   - matplotlib: For plotting and LaTeX rendering.

   These can be installed via pip:

   $ pip install pandas matplotlib

3. A 'results.txt' file in the current directory. This file should be structured as follows:
- Model1: Stellar model for the first star.
- Model2: Stellar model for the second star.
- Velocity: Relative velocity at infinity (in km/s).
- Periastron: Periastron separation (in units of R_1 + R_2).
- Initial Separation: Initial separation (normalized to the sum of the parent star radii).
- Max Density: Maximum density in the simulation (in g/cm^3).

Each row of this file corresponds to a simulation, with values separated by spaces.

Usage:
------
1. Ensure that the 'results.txt' file is present in the current directory.
2. Run the script:

    $ python plot_density.py

3. The heatmap will be displayed, showing maximum core density as a function of the chosen parameters. 
The plot can be customized by editing the script, such as changing font sizes or plot dimensions.

Customization:
--------------
- Font Size: You can adjust the font size for labels, ticks, titles, and annotations by providing input when prompted.
- LaTeX Rendering: Ensure that LaTeX is installed on your system for proper rendering of text 
within the plot. If LaTeX is not installed, remove or comment out the LaTeX-related lines 
in the script.

Interpolation Methods for Smoothing in imshow:
----------------------------------------------
The `imshow` function in Matplotlib allows for various interpolation methods that can control the smoothness of the image. 
The `interpolation` parameter can be adjusted to increase or decrease the smoothness of the heatmap. Below are some common options:

1. 'nearest': No interpolation, each pixel is displayed as a small square of one color.
2. 'bilinear': Linear interpolation in both x and y directions. Provides moderate smoothing.
3. 'bicubic': Cubic interpolation in both x and y directions. This is a good default for smooth transitions.
4. 'lanczos': Applies the Lanczos filter, which is known for producing very smooth results, particularly effective for downsampling.
5. 'spline16', 'spline36': Spline interpolation with different degrees, offering various levels of smoothness.
6. 'hanning', 'hamming', 'kaiser': Apply different window functions for interpolation, which can result in smooth transitions.

The script uses 'bicubic' for a balance between smoothness and performance, but you can increase the smoothing by using 'lanczos' or other interpolation methods depending on your needs.

Example Usage:
--------------
To apply a smoother interpolation, such as 'lanczos', replace the interpolation parameter in the `imshow` function like this:

plt.imshow(Z, cmap='Reds', extent=(X.min(), X.max(), Y.min(), Y.max()), origin='lower', interpolation='lanczos', aspect='auto')

Experiment with different methods to achieve the desired level of smoothness for your plot.
"""

# Define the expected number of columns
expected_columns = ['Model1', 'Model2', 'Velocity', 'Periastron', 'Initial_Separation', 'Max_Density']

# Load the results file into a DataFrame, skip bad lines
df = pd.read_csv('./results.txt', delim_whitespace=True, comment='#',
                 names=expected_columns, on_bad_lines='skip')

# Convert Max_Density to float, ensure other fields are correct
df['Max_Density'] = pd.to_numeric(df['Max_Density'], errors='coerce')
df = df.dropna()  # Drop rows with missing or invalid Max_Density

# Pivot table to create a 2D grid for pcolormesh
heatmap_data = df.pivot_table(index='Periastron', columns='Velocity', values='Max_Density', aggfunc="mean")

# Prompt the user for font sizes
label_fontsize = int(input("Enter font size for labels (default 24): ") or "24")
tick_fontsize = int(input("Enter font size for tick labels (default 20): ") or "20")
title_fontsize = int(input("Enter font size for title (default 24): ") or "24")
colorbar_fontsize = int(input("Enter font size for colorbar label (default 24): ") or "24")

# Check if the pivot table is empty
if heatmap_data.empty:
    print("Error: No data available for plotting. The pivot table is empty.")
else:
    # Ask the user to choose the plotting method
    plot_method = input("Choose the plotting method:\n(1) pcolormesh (discrete color transitions)\n(2) imshow (smooth color transitions)\nEnter your choice (1 or 2): ")

    interpolation_method = None
    if plot_method == '2':
        # Ask the user to choose the interpolation method for imshow
        interpolation_method = input(
            "Choose the interpolation method for imshow:\n"
            "(1) nearest: No interpolation, sharp pixels\n"
            "(2) bilinear: Linear interpolation, moderate smoothness\n"
            "(3) bicubic: Cubic interpolation, good smoothness\n"
            "(4) lanczos: Lanczos filter, very smooth\n"
            "(5) spline16: Spline interpolation, degree 16\n"
            "(6) spline36: Spline interpolation, degree 36\n"
            "(7) hanning: Hanning window function\n"
            "(8) hamming: Hamming window function\n"
            "(9) kaiser: Kaiser window function\n"
            "Enter your choice (1-9): "
        )

        interpolation_map = {
            '1': 'nearest',
            '2': 'bilinear',
            '3': 'bicubic',
            '4': 'lanczos',
            '5': 'spline16',
            '6': 'spline36',
            '7': 'hanning',
            '8': 'hamming',
            '9': 'kaiser'
        }

        interpolation_method = interpolation_map.get(interpolation_method, 'bicubic')

    # Set up LaTeX for rendering
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif', size=label_fontsize)  # Apply user-defined font size for labels

    # Extract X, Y, and Z data from the pivot table
    X, Y = np.meshgrid(heatmap_data.columns, heatmap_data.index)
    Z = heatmap_data.values

    # Plot based on user's choice
    plt.figure(figsize=(13, 8))  # Adjust the figure size to better balance the axes

    if plot_method == '1':
        mesh = plt.pcolormesh(X, Y, Z, cmap='Reds', edgecolors='none', shading='gouraud', linewidth=0.0)
    elif plot_method == '2':
        plt.imshow(Z, cmap='Reds', extent=(X.min(), X.max(), Y.min(), Y.max()), origin='lower', interpolation=interpolation_method, aspect='auto')
        mesh = None  # No mesh for imshow, colorbar will be generated without mesh reference
    else:
        print("Invalid choice. Defaulting to pcolormesh.")
        mesh = plt.pcolormesh(X, Y, Z, cmap='Reds', edgecolors='none', shading='gouraud', linewidth=0.0)

    # Add a color bar
    if mesh:
        cbar = plt.colorbar(mesh)
    else:
        cbar = plt.colorbar()

    cbar.set_label(r'$\mathrm{Max\ density\ (g/cm^3)}$', size=colorbar_fontsize)
    cbar.ax.tick_params(labelsize=tick_fontsize)
    cbar.ax.yaxis.set_label_position('right')
    cbar.ax.yaxis.labelpad = 15  # Adjust padding between the color bar and the plot

    # Customize the axes labels with LaTeX and user-defined font size
    plt.xlabel(r'$\mathrm{Velocity\ (km/s)}$', fontsize=label_fontsize)
    plt.ylabel(r'$\mathrm{Periastron\ distance\ (R_1\ +\ R_2)\,R_{\odot}}$', fontsize=label_fontsize, labelpad=12)

    # Optionally, you could add a title
    #plt.title(r'$\mathrm{Max\ Density\ as\ a\ function\ of\ velocity\ and\ periastron\ distance}$', fontsize=title_fontsize, pad=20)

    # Display the plot
    plt.show()


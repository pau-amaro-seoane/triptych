"""
Program: plot_density.py
Author: Pau Amaro Seoane
Date: 17 August 2024

Description:
------------
This Python script generates a heatmap that visualizes the maximum core density of stellar models 
as a function of various simulation parameters, such as relative velocity and periastron separation. 
The script reads the simulation results from a file named 'results.txt', which is generated by running 
the accompanying simulation script (e.g., run_simulations.sh). 

The heatmap is rendered using LaTeX for text formatting, ensuring high-quality labels and 
annotations. The script can be customized to adjust font sizes and other visual aspects 
of the plot.

The heatmap displays core density on the color bar with axes labeled by velocity and periastron separation.

Requirements:
-------------
1. Python 3.x
2. Required Python libraries:
   - pandas: For handling and processing the data.
   - matplotlib: For plotting and LaTeX rendering.

   These can be installed via pip:

   $ pip install pandas matplotlib

3. A 'results.txt' file in the current directory. This file should be structured as follows:
- Model1: Stellar model for the first star.
- Model2: Stellar model for the second star.
- Velocity: Relative velocity at infinity (in km/s).
- Periastron: Periastron separation (in units of R_1 + R_2).
- Initial Separation: Initial separation (normalized to the sum of the parent star radii).
- Max Density: Maximum density in the simulation (in g/cm^3).

Each row of this file corresponds to a simulation, with values separated by spaces.

Usage:
------
1. Ensure that the 'results.txt' file is present in the current directory.
2. Run the script:

    $ python plot_density.py

3. The script will prompt you to choose between two plotting methods:
   - `pcolormesh`: Generates a plot with distinct color blocks.
   - `imshow`: Generates a plot with smooth color transitions.

4. The heatmap will be displayed, showing maximum core density as a function of the chosen parameters. 
The plot can be customized by editing the script, such as changing font sizes or plot dimensions.

Customization:
--------------
- Font Size: You can adjust the font size for labels and annotations by modifying the `fontsize` 
and `annot_kws` parameters in the script.
- LaTeX Rendering: Ensure that LaTeX is installed on your system for proper rendering of text 
within the plot. If LaTeX is not installed, remove or comment out the LaTeX-related lines 
in the script.
- Axes and Labels: The script can be further customized to plot different parameters by adjusting 
the pivot table creation or the heatmap plotting sections.

Interpolation Methods for Smoothing in imshow:
----------------------------------------------

The `imshow` function in Matplotlib allows for various interpolation methods
that can control the smoothness of the image. The `interpolation` parameter can
be adjusted to increase or decrease the smoothness of the heatmap. Below are
some common options:

1. 'nearest': No interpolation, each pixel is displayed as a small square of one color.
2. 'bilinear': Linear interpolation in both x and y directions. Provides moderate smoothing.
3. 'bicubic': Cubic interpolation in both x and y directions. This is a good default for smooth transitions.
4. 'lanczos': Applies the Lanczos filter, which is known for producing very smooth results, particularly effective for downsampling.
5. 'spline16', 'spline36': Spline interpolation with different degrees, offering various levels of smoothness.
6. 'hanning', 'hamming', 'kaiser': Apply different window functions for interpolation, which can result in smooth transitions.

The script uses 'bicubic' for a balance between smoothness and performance, but
you can increase the smoothing by using 'lanczos' or other interpolation
methods depending on your needs.

Example Usage:
--------------

To apply a smoother interpolation, such as 'lanczos', replace the interpolation
parameter in the `imshow` function like this:

plt.imshow(Z, cmap='Reds', extent=(X.min(), X.max(), Y.min(), Y.max()), origin='lower', interpolation='lanczos', aspect='auto')

"""
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np


# Define the expected number of columns
expected_columns = ['Model1', 'Model2', 'Velocity', 'Periastron', 'Initial_Separation', 'Max_Density']

# Load the results file into a DataFrame, skip bad lines
df = pd.read_csv('./results.txt', delim_whitespace=True, comment='#',
                 names=expected_columns, on_bad_lines='skip')

# Convert Max_Density to float, ensure other fields are correct
df['Max_Density'] = pd.to_numeric(df['Max_Density'], errors='coerce')
df = df.dropna()  # Drop rows with missing or invalid Max_Density

# Pivot table to create a 2D grid for pcolormesh or imshow
heatmap_data = df.pivot_table(index='Periastron', columns='Velocity', values='Max_Density', aggfunc="mean")

# Check if the pivot table is empty
if heatmap_data.empty:
    print("Error: No data available for plotting. The pivot table is empty.")
else:
    # Ask the user to choose the plotting method
    plot_method = input("Choose plotting method: (1) pcolormesh (distinct color blocks) or (2) imshow (smooth transitions): ")

    # Set up LaTeX for rendering
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif', size=20)  # Change 'size' to adjust the global font size

    # Extract X, Y, and Z data from the pivot table
    X, Y = np.meshgrid(heatmap_data.columns, heatmap_data.index)
    Z = heatmap_data.values

    # Plot based on user's choice
    plt.figure(figsize=(13, 8))  # Adjust the figure size to better balance the axes
    
    if plot_method == '1':
        mesh = plt.pcolormesh(X, Y, Z, cmap='Reds', edgecolors='none', shading='gouraud', linewidth=0.0)
    elif plot_method == '2':
        plt.imshow(Z, cmap='Reds', extent=(X.min(), X.max(), Y.min(), Y.max()), origin='lower', interpolation='spline36', aspect='auto')
        mesh = None  # No mesh for imshow, colorbar will be generated without mesh reference
    else:
        print("Invalid choice. Defaulting to pcolormesh.")
        mesh = plt.pcolormesh(X, Y, Z, cmap='Reds', edgecolors='none', shading='gouraud', linewidth=0.0)
    
    # Add a color bar
    cbar = plt.colorbar(mesh if mesh is not None else plt.gca().images[-1])
    cbar.set_label(r'$\mathrm{Max\ density\ (g/cm^3)}$', size=24)
    cbar.ax.tick_params(labelsize=20)
    cbar.ax.yaxis.set_label_position('right')
    cbar.ax.yaxis.labelpad = 15  # Adjust padding between the color bar and the plot

    # Customize the axes labels with LaTeX and adjustable font size
    plt.xlabel(r'$\mathrm{Velocity\ (km/s)}$', fontsize=24)
    plt.ylabel(r'$\mathrm{Periastron\ distance\ (R_1\ +\ R_2)}$', fontsize=24)

    # Display the plot
    plt.show()

